%option never-interactive
%option prefix="rete"
%option noyywrap
%option yylineno

%{
#include <cstdio>
#include <cstring>
#include "rete_parser.h"

struct Condition_Base;
struct Rule;

#include "rules.tab.hpp"

#define YY_DECL int retelex()

using namespace std;
%}

%x READ_STRING
%%
[ \t\r]                                   ;
#.*                                       ;
<INITIAL,READ_STRING>\n                   { }
excise                                    { retelval.csval = "excise"; return COMMAND_EXCISE; }
exit                                      { retelval.csval = "exit"; return COMMAND_EXIT; }
insert-wme                                { retelval.csval = "insert-wme"; return COMMAND_INSERT_WME; }
remove-wme                                { retelval.csval = "remove-wme"; return COMMAND_REMOVE_WME; }
sp                                        { retelval.csval = "sp"; return COMMAND_SP; }
:filter                                   { retelval.sval = new string(retetext); return FLAG; }
-?[0-9]+\.[0-9]+                          { retelval.fval = atof(retetext); return FLOAT; }
-?[0-9]+                                  { retelval.ival = atoi(retetext); return INT; }
\<[a-zA-Z0-9\-\*]+\>                      { retelval.sval = new string(retetext + 1);
                                            retelval.sval->resize(retelval.sval->size() - 1);
                                            return VARIABLE;
                                          }
[a-zA-Z0-9]+                              { retelval.sval = new string(retetext); return STRING; }
[a-zA-Z0-9]+[a-zA-Z0-9\-*]*[a-zA-Z0-9]+   { retelval.sval = new string(retetext); return STRING; }
[\^\(\)\{\}+-]                            { return retetext[0]; }
==                                        { retelval.predicate = Rete::Rete_Predicate::EQ; return PREDICATE; }
!=                                        { retelval.predicate = Rete::Rete_Predicate::NEQ; return PREDICATE; }
>                                         { retelval.predicate = Rete::Rete_Predicate::GT; return PREDICATE; }
>=                                        { retelval.predicate = Rete::Rete_Predicate::GTE; return PREDICATE; }
\<                                        { retelval.predicate = Rete::Rete_Predicate::LT; return PREDICATE; }
\<=                                       { retelval.predicate = Rete::Rete_Predicate::LTE; return PREDICATE; }
\|                                        { BEGIN(READ_STRING); return '|'; }
<READ_STRING>\\\|                         { retelval.sval = new string("\\|"); return STRING_PART_S; }
<READ_STRING>\\t                          { retelval.sval = new string("\\t"); return STRING_PART_S; }
<READ_STRING>\\r                          { retelval.sval = new string("\\r"); return STRING_PART_S; }
<READ_STRING>\\n                          { retelval.sval = new string("\\n"); return STRING_PART_S; }
<READ_STRING>\|                           { BEGIN(INITIAL); return '|'; }
<READ_STRING>\r                           ;
<READ_STRING>[^\|\r\n]                    { retelval.cval = retetext[0]; return STRING_PART_C; }
%%
