%output "rules.tab.cpp"
%defines "rules.tab.hh"
%name-prefix "rete"
%define api.pure full
%error-verbose
%locations

%lex-param { yyscan_t yyscanner }
%parse-param { yyscan_t yyscanner }
%parse-param { Carli::Agent &agent }
%parse-param { const std::string &filename }
%parse-param { const std::string &source_path }

%code requires {
#ifndef YY_TYPEDEF_YY_SCANNER_T
#define YY_TYPEDEF_YY_SCANNER_T
typedef void *yyscan_t;
#endif
}

%code {
#include "lex.rete.hh"

static volatile sig_atomic_t g_rete_exit = false;

static void reteerror(const YYLTYPE * const /*yylloc*/, yyscan_t const yyscanner, Rete::Rete_Agent &/*agent*/, const std::string &filename, const std::string &/*source_path*/, const char *msg) {
  if(filename.empty())
    cout << "rete-parse error: " << msg << endl;
  else
    cout << "rete-parse error " << filename << '(' << reteget_lineno(yyscanner) << "): " << msg << endl;
}
}

%{
#define YY_NO_UNISTD_H 1
#include <csignal>
#include <cstdio>
#include <sstream>
#include "rete_parser.h"

using namespace std;

namespace Rete {

  static unordered_map<string, shared_ptr<tuple<double, double, bool>>> * Flags(const string &flag, const shared_ptr<tuple<double, double, bool>> &value, std::unordered_map<std::string, std::shared_ptr<std::tuple<double, double, bool>>> * flags = nullptr) {
    if(!flags)
      flags = new std::unordered_map<std::string, std::shared_ptr<std::tuple<double, double, bool>>>;
    (*flags)[flag] = value;
    return flags;
  }

  static pair<Rete::Rete_Node_Ptr, Variable_Indices> *
  Rete_Node_Ptr_and_Variables(const Rete::Rete_Node_Ptr &rete_node, const Variable_Indices &variables) {
    return new pair<Rete::Rete_Node_Ptr, Variable_Indices>(rete_node, variables);
  }

  static Rete::WME_Token_Index find_index(const Variable_Indices &variables, const std::string &name) {
    const auto found = variables.find(name);
    return found != variables.end() && !found->second.existential ? found->second : Rete::WME_Token_Index(-1, -1, -1);
  }

  static Rete::WME_Bindings join_bindings(const Variable_Indices &lhs,
                                          const Variable_Indices &rhs)
  {
    Rete::WME_Bindings bindings;
    unordered_set<string> joined;
    for(const auto &rvar : rhs) {
      if(!rvar.second.existential) {
        const auto found = lhs.find(rvar.first);
        if(found != lhs.end() && !found->second.existential && joined.find(rvar.first) == joined.end()) {
          bindings.insert(Rete::WME_Binding(found->second, rvar.second));
          joined.insert(rvar.first);
        }
      }
    }
    return bindings;
  }

  static Variable_Indices merge_variables(const Variable_Indices &lhs, const int64_t &lhs_size, const int64_t &lhs_token_size, const Variable_Indices &rhs, const bool &existential) {
    Variable_Indices variables(lhs);
    for(auto rvar : rhs) {
      const auto found = lhs.find(rvar.first);
      if(found == lhs.end() || found->second.existential) {
        rvar.second.rete_row += lhs_size;
        rvar.second.token_row += lhs_token_size;
        rvar.second.existential = rvar.second.existential | existential;
        variables.insert(rvar);
      }
    }
    return variables;
  }

}

%}

%union {
  char cval;
  const char *csval;
  Rete::Parser_Flag *flag_ptr;
  double fval;
  int64_t ival;
  std::list<std::string> *slist;
  std::string *sval;
  Rete::Parser_Rete_Node *rete_node_ptr;
  Rete::Parser_Rule *rule_ptr;
  Rete::Symbol_Ptr_C *symbol_ptr;
  Rete::Rete_Predicate::Predicate predicate;
}

%token <csval> ARROW_RIGHT
%token <csval> ASSIGNMENT
%token <csval> COMMAND_EXCISE
%token <csval> COMMAND_EXCISE_ALL
%token <csval> COMMAND_EXIT
%token <csval> COMMAND_INSERT_WME
%token <csval> COMMAND_REMOVE_WME
%token <csval> COMMAND_SET_RULE_NAME_INDEX
%token <csval> COMMAND_SET_TOTAL_STEP_COUNT
%token <csval> COMMAND_SOURCE
%token <csval> COMMAND_SP
%token <csval> FLAG_CREATION_TIME
%token <csval> FLAG_FEATURE
%token <fval> FLOAT
%token <ival> INT
%token <sval> NODE_TYPE
%token <sval> STRING
%token <cval> STRING_PART_C
%token <sval> STRING_PART_S
%token <sval> VARIABLE
%token <predicate> PREDICATE

%type <flag_ptr> flags
%type <fval> number
%type <rete_node_ptr> final_conditions conditions condition_group condition_type condition
%type <rule_ptr> rule
%type <sval> string_or_literal literal literal_parts
%type <symbol_ptr> symbol identifier symbol_constant

%%
commands:
  | commands command { /*cerr << "Read in rule on line " << reteget_lineno(yyscanner) << endl;*/ }
  ;
command:
  COMMAND_EXCISE STRING { agent.excise_rule(*$2, true);
                          delete $2; }
  | COMMAND_EXCISE_ALL { agent.excise_all(); }
  | COMMAND_EXIT { g_rete_exit = true;
                   YYACCEPT; }
  | COMMAND_INSERT_WME '(' symbol '^' symbol symbol ')' { const auto wme = make_shared<Rete::WME>(*$3, *$5, *$6);
                                                          agent.insert_wme(wme);
                                                          delete $3;
                                                          delete $5;
                                                          delete $6; }
  | COMMAND_REMOVE_WME '(' symbol '^' symbol symbol ')' { const auto wme = make_shared<Rete::WME>(*$3, *$5, *$6);
                                                          agent.remove_wme(wme);
                                                          delete $3;
                                                          delete $5;
                                                          delete $6; }
  | COMMAND_SET_RULE_NAME_INDEX INT { agent.set_rule_name_index($2); }
  | COMMAND_SET_TOTAL_STEP_COUNT INT { agent.set_total_step_count($2); }
  | COMMAND_SOURCE string_or_literal { const int rv = rete_parse_file(agent, *$2, source_path);
                                       if(rv) {
                                         ostringstream oss;
                                         oss << "Error sourcing '" << *$2 << "'.";
                                         reteerror(&yylloc, yyscanner, agent, filename, source_path, oss.str().c_str());
                                         delete $2;
                                         YYABORT;
                                       }
                                       delete $2;
                                       if(g_rete_exit) {
                                         YYACCEPT;
                                       } }
  | COMMAND_SP rule { const auto &parent =                            get<0>(*$2).first;
                      const auto &variable_names =                    get<0>(*$2).second;
                      const string &name =                            get<1>(*$2);
                      const int64_t &timestamp =              *get<0>(get<2>(*$2));
                      const int64_t &q_value_depth =   get<0>(*get<1>(get<2>(*$2)));
                      const string &node_type =        get<1>(*get<1>(get<2>(*$2)));
                      const string &parent_node_name = get<2>(*get<1>(get<2>(*$2)));
                      const auto &feature =            get<3>(*get<1>(get<2>(*$2)));
                      const auto &q_value_value =                     get<3>(*$2);
                      const auto variable_indices = std::make_shared<Rete::Variable_Indices>(variable_names);
                      const auto parent_action = agent.get_rule(parent_node_name);

                      if(q_value_depth != 1 && !parent_action) {
                        reteerror(&yylloc, yyscanner, agent, filename, source_path, "Parent action not found!");
                        delete $2;
                        break;
                      }

                      if(q_value_depth != 1 && !feature) {
                        reteerror(&yylloc, yyscanner, agent, filename, source_path, "Missing feature!");
                        delete $2;
                        YYABORT;
                      }

                      const auto existing = agent.unname_rule(name, true);
                      if(existing) {
                        parent->suppress_destruction(true);
                        existing->destroy(agent);
                      }

                      Rete::Rete_Action_Ptr new_action;
                      if(node_type.empty()) {
                        /// Non-RL node
                        auto node = agent.make_action_retraction(name, true,
                                                                 [](const Rete::Rete_Action &action, const Rete::WME_Token &wme_vector) {
                                                                   cout << wme_vector << "->" << action.get_name() << endl;
                                                                 }, [](const Rete::Rete_Action &action, const Rete::WME_Token &wme_vector) {
                                                                   cout << wme_vector << "<-" << action.get_name() << endl;
                                                                 }, parent, make_shared<Rete::Variable_Indices>());
                      }
                      else {
                        if(feature) {
                          auto test_node_rightmost = parent;
                          bool test_node_rightmost_existential = false;
                          while(test_node_rightmost->get_bindings()) {
                            test_node_rightmost_existential |= dynamic_cast<Rete::Rete_Existential_Join *>(test_node_rightmost.get()) || dynamic_cast<Rete::Rete_Negation_Join *>(test_node_rightmost.get());
                            test_node_rightmost = test_node_rightmost->parent_right();
                          }

                          /// Fill in Feature values / predicate tests
                          if(const auto feature_e = dynamic_cast<Carli::Feature_Enumerated<Carli::Feature> *>(feature)) {
                            /// TODO: Handle variable-to-variable relations
                            if(const auto predicate = dynamic_cast<Rete::Rete_Predicate *>(test_node_rightmost.get())) {
                              const auto rhs = predicate->get_rhs().get();
                              const auto symbol_i = dynamic_cast<const Rete::Symbol_Constant_Int *>(rhs);
                              assert(symbol_i);
                              feature_e->value = symbol_i->value;
                            }
                            else if(dynamic_cast<Rete::Rete_Existential_Join *>(parent.get()))
                              feature_e->value = true;
                            else if(dynamic_cast<Rete::Rete_Negation_Join *>(parent.get()))
                              feature_e->value = false;
                            else {
                              reteerror(&yylloc, yyscanner, agent, filename, source_path, "Error reading enumerated feature value / predicate test.");
                              YYABORT;
                            }
                          }
                          else if(const auto feature_r = dynamic_cast<Carli::Feature_Ranged<Carli::Feature> *>(feature)) {
                            const auto &predicate = dynamic_cast<Rete::Rete_Predicate &>(*test_node_rightmost);
                            switch(predicate.get_predicate()) {
                              case Rete::Rete_Predicate::GT:
                              case Rete::Rete_Predicate::GTE:
                              case Rete::Rete_Predicate::LT:
                              case Rete::Rete_Predicate::LTE:
                                feature_r->predicate = predicate.get_predicate();
                                break;

                              default:
                                reteerror(&yylloc, yyscanner, agent, filename, source_path, "Invalid ranged feature predicate selection.");
                                YYABORT;
                            }
                          }
                          else if(const auto feature_n = dynamic_cast<Carli::Feature_NullHOG<Carli::Feature> *>(feature)) {
                            /// TODO: Handle variable-to-variable relations
                            if(Rete::Rete_Node * node_ptr = dynamic_cast<Rete::Rete_Negation_Join *>(parent.get())) {
                              auto next_ptr = node_ptr->parent_right().get();
                              while(dynamic_cast<Rete::Rete_Predicate *>(next_ptr))
                                next_ptr = next_ptr->parent_left().get();
                              if(Rete::Rete_Join * const join_ptr = dynamic_cast<Rete::Rete_Join *>(next_ptr)) {
                                if(dynamic_cast<Rete::Rete_Filter *>(join_ptr->parent_right().get())) {
                                  auto vt = variable_names.begin(); //, vend = variable.names.end();
                                  auto pt = parent_action->get_variables()->begin(), pend = parent_action->get_variables()->end();
                                  while(pt != pend && *vt == *pt)
                                    ++pt, ++vt;
                                  feature_n->value = vt->first;
                                }
                                else {
                                  reteerror(&yylloc, yyscanner, agent, filename, source_path, "Error reading null HOG test (type 3).");
                                  YYABORT;
                                }
                              }
                              else if(dynamic_cast<Rete::Rete_Filter *>(next_ptr)) {
                                auto vt = variable_names.begin(); //, vend = variable.names.end();
                                auto pt = parent_action->get_variables()->begin(), pend = parent_action->get_variables()->end();
                                while(pt != pend && *vt == *pt)
                                  ++pt, ++vt;
                                feature_n->value = vt->first;
                              }
                              else {
                                reteerror(&yylloc, yyscanner, agent, filename, source_path, "Error reading null HOG test (type 2).");
                                YYABORT;
                              }
                            }
                            else {
                              reteerror(&yylloc, yyscanner, agent, filename, source_path, "Error reading null HOG test (type 1).");
                              YYABORT;
                            }
                          }
                          else {
                            reteerror(&yylloc, yyscanner, agent, filename, source_path, "Error reading enumerated/ranged feature value / predicate test.");
                            YYABORT;
                          }

                          /// Determine Feature axes
                          if(const auto predicate = dynamic_cast<const Rete::Rete_Predicate *>(test_node_rightmost.get())) {
                            feature->axis = predicate->get_lhs_index();
                            feature->axis.existential = test_node_rightmost_existential;
                          }
                          else if(dynamic_cast<Rete::Rete_Existential_Join *>(parent.get()) ||
                                  dynamic_cast<Rete::Rete_Negation_Join *>(parent.get()))
                          {
                            feature->axis = Rete::WME_Token_Index(-1, -1, -1);
                          }
                          else {
                            Rete::Rete_Node_Ptr test_node = parent;
                            const Rete::Rete_Filter * filter_node = dynamic_cast<const Rete::Rete_Filter *>(test_node->parent_right().get());
                            while(!filter_node) {
                              test_node = test_node->parent_right();
                              filter_node = dynamic_cast<const Rete::Rete_Filter *>(test_node->parent_right().get());
                            }

                            if(const auto bindings = test_node->get_bindings()) {
                              for(const auto binding : *bindings) {
                                if(binding.second == Rete::WME_Token_Index(0, 0, 0)) {
                                  feature->axis = binding.first;
                                  goto AXIS_FOUND;
                                }
                              }
                            }
                            reteerror(&yylloc, yyscanner, agent, filename, source_path, "Error determining Feature axis.");
                            YYABORT;
                            AXIS_FOUND:
                              ;
                          }

                          if(feature->get_depth() > 1) {
                            const auto predicate = dynamic_cast<const Rete::Rete_Predicate *>(parent.get());
                            assert(predicate);
                            if(predicate) {
                              auto ancestor = parent_action;
                              auto ancestor_prev = ancestor;
                              assert(ancestor && dynamic_cast<const Carli::Node *>(ancestor->data.get())->q_value_fringe->feature);
                              while(ancestor && dynamic_cast<const Carli::Node *>(ancestor->data.get())->q_value_fringe->feature &&
                                    ancestor->get_token_size() > predicate->get_lhs_index().token_row)
                              {
                                ancestor_prev = ancestor;
                                ancestor = dynamic_cast<const Carli::Node *>(ancestor->data.get())->parent_action.lock();
                              }

                              assert(ancestor);
                              if(ancestor) {
                                const auto ancestor_node = dynamic_cast<const Carli::Node *>(ancestor_prev->data.get());
                                assert(ancestor_node);
                                assert(ancestor_node->q_value_fringe);
                                assert(ancestor_node->q_value_fringe->feature);
                                feature->bindings = ancestor_node->q_value_fringe->feature->bindings;
                                feature->conditions = ancestor_node->q_value_fringe->feature->conditions;
                              }
                              else
                                feature->bindings.insert(std::make_pair(predicate->get_lhs_index(), Rete::WME_Token_Index(-1, -1, -1)));
                            }
                          }
                          else {
                            if(parent->get_bindings()) {
                              feature->bindings = *parent->get_bindings();
                              feature->conditions = parent->parent_right()->get_filter_wmes();
                            }
                            if(auto predicate = dynamic_cast<const Rete::Rete_Predicate *>(parent.get()))
                              feature->bindings.insert(std::make_pair(predicate->get_lhs_index(), Rete::WME_Token_Index(-1, -1, -1)));
                          }

                          if(feature->axis.rete_row != -1 && parent->get_bindings()) {
                            if(feature->axis.existential && dynamic_cast<const Carli::Feature_Ranged_Data *>(feature)) {
                              reteerror(&yylloc, yyscanner, agent, filename, source_path, "Refineable feature illegally declared existential.");
                              YYABORT;
                            }
                            feature->axis.rete_row += parent->parent_left()->get_size();
                            feature->axis.token_row += parent->parent_left()->get_token_size();
                          }
                          feature->indices = variable_indices;

                          //std::cerr << "LHS" << feature->axis << ' ' << *variable_indices << std::endl;
                        }

                        /// Make the new action
                        if(node_type != "fringe") {
                          Carli::Node_Ptr new_action_data;
                          if(node_type == "split") {
                            const auto new_q_value_weight = new Carli::Q_Value(q_value_value, Carli::Q_Value::Type::SPLIT, q_value_depth, feature ? feature->clone() : nullptr, timestamp);
                            const auto new_q_value_fringe = new Carli::Q_Value(Carli::Q_Value::Token() /** HACK: Not stored in written rules. */, Carli::Q_Value::Type::FRINGE, q_value_depth, feature, timestamp);
                            new_action = agent.make_standard_action(parent, name, true, variable_indices);
                            new_action_data = std::make_shared<Carli::Node_Split>(agent, parent_action, new_action, new_q_value_weight, new_q_value_fringe);
                            new_action->data = new_action_data;
                          }
                          else {
                            assert(node_type == "unsplit");
                            const auto new_q_value_weight = new Carli::Q_Value(q_value_value, Carli::Q_Value::Type::UNSPLIT, q_value_depth, feature ? feature->clone() : nullptr, timestamp);
                            const auto new_q_value_fringe = new Carli::Q_Value(Carli::Q_Value::Token() /** HACK: Not stored in written rules. */, Carli::Q_Value::Type::FRINGE, q_value_depth, feature, timestamp);
                            new_action = agent.make_standard_action(parent, name, true, variable_indices);
                            new_action_data = std::make_shared<Carli::Node_Unsplit>(agent, parent_action, new_action, new_q_value_weight, new_q_value_fringe);
                            new_action->data = new_action_data;
                          }
                          if(parent_action) {
                            auto &parent_data = dynamic_cast<Carli::Node_Split &>(*parent_action->data);
//#ifndef NDEBUG
//                            std::cerr << "Adding child node link from " << parent_action->get_name() << " to " << new_action_data << std::endl;
//#endif
                            parent_data.children.push_back(new_action_data);
                          }
                          else if(new_action_data->q_value_fringe->depth != 1) {
                            reteerror(&yylloc, yyscanner, agent, filename, source_path, "Ancestral relationship specified in :feature not found.");
                            YYABORT;
                          }
#ifndef NDEBUG
                          Carli::Node_Tracker::get().create(*new_action);
#endif
                        }
                        else {
                          const auto new_q_value_fringe = new Carli::Q_Value(q_value_value, Carli::Q_Value::Type::FRINGE, q_value_depth, feature, timestamp);
                          new_action = agent.make_standard_action(parent, name, true, variable_indices);
                          auto new_action_data = std::make_shared<Carli::Node_Fringe>(agent, parent_action, new_action, nullptr, new_q_value_fringe);
                          new_action->data = new_action_data;
                          if(parent_action) {
                            if(const auto &parent_data = dynamic_cast<Carli::Node_Split *>(parent_action->data.get()))
                              parent_data->fringe_values[feature].push_back(new_action_data);
                            else if(const auto &parent_data = dynamic_cast<Carli::Node_Unsplit *>(parent_action->data.get()))
                              parent_data->fringe_values[feature].push_back(new_action_data);
                            else {
                              reteerror(&yylloc, yyscanner, agent, filename, source_path, "Parent data for fringe node inaccessible.");
                              YYABORT;
                            }
                          }
                          else {
                            reteerror(&yylloc, yyscanner, agent, filename, source_path, "Ancestral relationship specified in :feature fringe not found.");
                            YYABORT;
                          }
                        }

                        if(!get_Option_Ranged<bool>(Options::get_global(), "rete-disable-node-sharing") && parent_action) {
                          bool ancestor_found = false;
                          auto ancestor = parent;
                          while(ancestor && !ancestor_found) {
                            if(ancestor == parent_action->parent_left())
                              ancestor_found = true;
                            else if(!dynamic_cast<Rete::Rete_Filter *>(ancestor.get()))
                              ancestor = ancestor->parent_left();
                            else
                              break;
                          }
                          if(!ancestor_found) {
                            reteerror(&yylloc, yyscanner, agent, filename, source_path, "Illegal ancestral relationship specified in :feature.");
                            YYABORT;
                          }
                        }
                      }

                      parent->suppress_destruction(false);
                      delete $2; }
  ;
rule:
  '{' STRING flags final_conditions '}' { if(!get<0>(*$3))
                                            get<0>(*$3) = make_shared<int64_t>(agent.get_total_step_count());
                                          if(!get<1>(*$3))
                                            get<1>(*$3) = make_shared<tuple<int64_t, string, string, Carli::Feature *>>();
                                          $$ = new tuple<pair<Rete::Rete_Node_Ptr, Rete::Variable_Indices>, string, tuple<shared_ptr<int64_t>, shared_ptr<tuple<int64_t, string, string, Carli::Feature *>>>, Carli::Q_Value::Token>(*$4, *$2, *$3, Carli::Q_Value::Token());
                                          delete $2;
                                          delete $3;
                                          delete $4; }
  | '{' STRING flags final_conditions ARROW_RIGHT ASSIGNMENT number number number number INT '}'
        { if(!get<0>(*$3))
            get<0>(*$3) = make_shared<int64_t>(agent.get_total_step_count());
          if(!get<1>(*$3))
            get<1>(*$3) = make_shared<tuple<int64_t, string, string, Carli::Feature *>>();
          $$ = new tuple<pair<Rete::Rete_Node_Ptr, Rete::Variable_Indices>, string, tuple<shared_ptr<int64_t>, shared_ptr<tuple<int64_t, string, string, Carli::Feature *>>>, Carli::Q_Value::Token>(*$4, *$2, *$3, Carli::Q_Value::Token($7, $8, $9, $10, $11));
          delete $2;
          delete $3;
          delete $4; }
  | '{' STRING flags final_conditions ARROW_RIGHT ASSIGNMENT number '}'
        { if(!get<0>(*$3))
            get<0>(*$3) = make_shared<int64_t>(agent.get_total_step_count());
          if(!get<1>(*$3))
            get<1>(*$3) = make_shared<tuple<int64_t, string, string, Carli::Feature *>>();
          $$ = new tuple<pair<Rete::Rete_Node_Ptr, Rete::Variable_Indices>, string, tuple<shared_ptr<int64_t>, shared_ptr<tuple<int64_t, string, string, Carli::Feature *>>>, Carli::Q_Value::Token>(*$4, *$2, *$3, Carli::Q_Value::Token($7, 0.0, 0.0, 0.0, 0));
          delete $2;
          delete $3;
          delete $4; }
  ;
flags:
  /* :feature q_value->depth [feature->depth feature->lower_bound feature->upper_bound] */
  { $$ = new tuple<shared_ptr<int64_t>, shared_ptr<tuple<int64_t, string, string, Carli::Feature *>>>; }
  | flags FLAG_CREATION_TIME INT { if(get<0>(*$1)) {
                                     reteerror(&yylloc, yyscanner, agent, filename, source_path, "Flag :creation-time set more than once.");
                                     YYABORT;
                                   }
                                   $$ = $1;
                                   get<0>(*$$) = make_shared<int64_t>($3); }
  | flags FLAG_FEATURE INT NODE_TYPE INT STRING INT FLOAT FLOAT { if(get<1>(*$1)) {
                                                                    reteerror(&yylloc, yyscanner, agent, filename, source_path, "Flag :feature set more than once.");
                                                                    YYABORT;
                                                                  }
                                                                  if($5 < 1 || $5 > 2) {
                                                                    reteerror(&yylloc, yyscanner, agent, filename, source_path, "Only unary and binary ranged HOG features support.");
                                                                    YYABORT;
                                                                  }
                                                                  $$ = $1;
                                                                  get<1>(*$$) = make_shared<tuple<int64_t, string, string, Carli::Feature *>>($3, *$4, *$6, new Carli::Feature_Ranged<Carli::Feature>(vector<Rete::WME>() /*FIXUP Later*/, Rete::WME_Bindings() /*FIXUP later*/, Rete::WME_Token_Index() /*FIXUP later*/, nullptr /*FIXUP later*/, $5, $8, $9, $7, Rete::Rete_Predicate::EQ /*FIXUP later*/, false));
                                                                  delete $4;
                                                                  delete $6; }
  | flags FLAG_FEATURE INT NODE_TYPE INT STRING INT INT INT { if(get<1>(*$1)) {
                                                                reteerror(&yylloc, yyscanner, agent, filename, source_path, "Flag :feature set more than once.");
                                                                YYABORT;
                                                              }
                                                              if($5 < 1 || $5 > 2) {
                                                                reteerror(&yylloc, yyscanner, agent, filename, source_path, "Only unary and binary ranged HOG features support.");
                                                                YYABORT;
                                                              }
                                                              $$ = $1;
                                                              get<1>(*$$) = make_shared<tuple<int64_t, string, string, Carli::Feature *>>($3, *$4, *$6, new Carli::Feature_Ranged<Carli::Feature>(vector<Rete::WME>() /*FIXUP Later*/, Rete::WME_Bindings() /*FIXUP later*/, Rete::WME_Token_Index() /*FIXUP later*/, nullptr /*FIXUP later*/, $5, $8, $9, $7, Rete::Rete_Predicate::EQ /*FIXUP later*/, true));
                                                              delete $4;
                                                              delete $6; }
  | flags FLAG_FEATURE INT NODE_TYPE INT STRING { if(get<1>(*$1)) {
                                                    reteerror(&yylloc, yyscanner, agent, filename, source_path, "Flag :feature set more than once.");
                                                    YYABORT;
                                                  }
                                                  if($5 < 0 || $5 > 2) {
                                                    reteerror(&yylloc, yyscanner, agent, filename, source_path, "Only null-HOG and unary and binary enumerable features supported.");
                                                    YYABORT;
                                                  }
                                                  if($3 <= 1) {
                                                    reteerror(&yylloc, yyscanner, agent, filename, source_path, "Cannot have a (HOG) root feature.");
                                                    YYABORT;
                                                  }
                                                  $$ = $1;
                                                  if($5 == 0)
                                                    get<1>(*$$) = make_shared<tuple<int64_t, string, string, Carli::Feature *>>($3, *$4, *$6, new Carli::Feature_NullHOG<Carli::Feature>(vector<Rete::WME>() /*FIXUP Later*/, Rete::WME_Bindings() /*FIXUP later*/, Rete::WME_Token_Index(), nullptr /*FIXUP later*/, 0, "" /*FIXUP later*/));
                                                  else
                                                    get<1>(*$$) = make_shared<tuple<int64_t, string, string, Carli::Feature *>>($3, *$4, *$6, new Carli::Feature_Enumerated<Carli::Feature>(vector<Rete::WME>() /*FIXUP Later*/, Rete::WME_Bindings() /*FIXUP later*/, Rete::WME_Token_Index() /*FIXUP later*/, nullptr /*FIXUP later*/, $5, 0 /*FIXUP later*/));
                                                  delete $4;
                                                  delete $6; }
  | flags FLAG_FEATURE INT NODE_TYPE STRING INT FLOAT FLOAT { if(get<1>(*$1)) {
                                                                reteerror(&yylloc, yyscanner, agent, filename, source_path, "Flag :feature set more than once.");
                                                                YYABORT;
                                                              }
                                                              $$ = $1;
                                                              get<1>(*$$) = make_shared<tuple<int64_t, string, string, Carli::Feature *>>($3, *$4, *$5, new Carli::Feature_Ranged<Carli::Feature>(vector<Rete::WME>() /*FIXUP Later*/, Rete::WME_Bindings() /*FIXUP later*/, Rete::WME_Token_Index() /*FIXUP later*/, nullptr /*FIXUP later*/, -1, $7, $8, $6, Rete::Rete_Predicate::EQ /*FIXUP later*/, false));
                                                              delete $4;
                                                              delete $5; }
  | flags FLAG_FEATURE INT NODE_TYPE STRING INT INT INT { if(get<1>(*$1)) {
                                                            reteerror(&yylloc, yyscanner, agent, filename, source_path, "Flag :feature set more than once.");
                                                            YYABORT;
                                                          }
                                                          $$ = $1;
                                                          get<1>(*$$) = make_shared<tuple<int64_t, string, string, Carli::Feature *>>($3, *$4, *$5, new Carli::Feature_Ranged<Carli::Feature>(vector<Rete::WME>() /*FIXUP Later*/, Rete::WME_Bindings() /*FIXUP later*/, Rete::WME_Token_Index() /*FIXUP later*/, nullptr /*FIXUP later*/, -1, $7, $8, $6, Rete::Rete_Predicate::EQ /*FIXUP later*/, true));
                                                          delete $4;
                                                          delete $5; }
  | flags FLAG_FEATURE INT NODE_TYPE STRING { if(get<1>(*$1)) {
                                                reteerror(&yylloc, yyscanner, agent, filename, source_path, "Flag :feature set more than once.");
                                                YYABORT;
                                              }
                                              $$ = $1;
                                              if($3 > 1)
                                                get<1>(*$$) = make_shared<tuple<int64_t, string, string, Carli::Feature *>>($3, *$4, *$5, new Carli::Feature_Enumerated<Carli::Feature>(vector<Rete::WME>() /*FIXUP Later*/, Rete::WME_Bindings() /*FIXUP later*/, Rete::WME_Token_Index() /*FIXUP later*/, nullptr /*FIXUP later*/, -1, 0 /*FIXUP later*/));
                                              else
                                                get<1>(*$$) = make_shared<tuple<int64_t, string, string, Carli::Feature *>>(1, *$4, "", nullptr);
                                              delete $4;
                                              delete $5; }
  ;
final_conditions:
  conditions { $$ = $1; }
  | '+' conditions { $$ = Rete_Node_Ptr_and_Variables(Rete::Rete_Node_Ptr(agent.make_existential($2->first)), Rete::Variable_Indices()); delete $2; }
  | '-' conditions { $$ = Rete_Node_Ptr_and_Variables(Rete::Rete_Node_Ptr(agent.make_negation($2->first)), Rete::Variable_Indices()); delete $2; }
  ;
conditions:
  conditions condition_type { const Rete::Variable_Indices variables(merge_variables($1->second, $1->first->get_size(), $1->first->get_token_size(), $2->second, false));
                              $$ = Rete_Node_Ptr_and_Variables(Rete::Rete_Node_Ptr(agent.make_join(join_bindings($1->second, $2->second), $1->first, $2->first)), variables);
                              delete $1;
                              delete $2; }
  | conditions '+' condition_type { const Rete::Variable_Indices variables(merge_variables($1->second, $1->first->get_size(), $1->first->get_token_size(), $3->second, true));
                                    $$ = Rete_Node_Ptr_and_Variables(Rete::Rete_Node_Ptr(agent.make_existential_join(join_bindings($1->second, $3->second), $1->first, $3->first)), variables);
                                    delete $1;
                                    delete $3; }
  | conditions '-' condition_type { const Rete::Variable_Indices variables(merge_variables($1->second, $1->first->get_size(), $1->first->get_token_size(), $3->second, true));
                                    $$ = Rete_Node_Ptr_and_Variables(Rete::Rete_Node_Ptr(agent.make_negation_join(join_bindings($1->second, $3->second), $1->first, $3->first)), variables);
                                    delete $1;
                                    delete $3; }
  | conditions '(' VARIABLE PREDICATE symbol_constant ')' { const auto lhs_index = find_index($1->second, *$3);
                                                            if(lhs_index.column > 2) {
                                                              reteerror(&yylloc, yyscanner, agent, filename, source_path, "Unbound variable tested by predicate.");
                                                              YYABORT;
                                                            }
                                                            $$ = Rete_Node_Ptr_and_Variables(Rete::Rete_Node_Ptr(agent.make_predicate_vc($4, lhs_index, *$5, $1->first)), $1->second);
                                                            delete $1;
                                                            delete $3;
                                                            delete $5; }
  | conditions '(' VARIABLE PREDICATE VARIABLE ')' { const auto lhs_index = find_index($1->second, *$3);
                                                     const auto rhs_index = find_index($1->second, *$5);
                                                     if(lhs_index.column > 2 || rhs_index.column > 2) {
                                                       reteerror(&yylloc, yyscanner, agent, filename, source_path, "Unbound variable tested by predicate.");
                                                       YYABORT;
                                                     }
                                                     $$ = Rete_Node_Ptr_and_Variables(Rete::Rete_Node_Ptr(agent.make_predicate_vv($4, lhs_index, rhs_index, $1->first)), $1->second);
                                                     delete $1;
                                                     delete $3;
                                                     delete $5; }
  | condition_type { $$ = $1; }
  ;
condition_group:
  '{' final_conditions '}' { $$ = $2; }
  | '&' STRING { const auto referenced_action = agent.get_rule(*$2);
                 $$ = Rete_Node_Ptr_and_Variables(referenced_action->parent_left(), *referenced_action->get_variables());
                 delete $2; }
  ;
condition_type:
  condition { $$ = $1; }
  | condition_group { $$ = $1; }
  ;
condition:
  '(' VARIABLE '^' symbol_constant symbol_constant ')' { $$ = Rete_Node_Ptr_and_Variables(Rete::Rete_Node_Ptr(agent.make_filter(Rete::WME(make_shared<Rete::Symbol_Variable>(Rete::Symbol_Variable::First), *$4, *$5))), Rete::Variable_Indices({{std::make_pair(*$2, Rete::WME_Token_Index(0, 0, 0))}})); delete $2; delete $4; delete $5; }
  | '(' VARIABLE '^' symbol_constant VARIABLE ')'  { $$ = Rete_Node_Ptr_and_Variables(Rete::Rete_Node_Ptr(agent.make_filter(Rete::WME(make_shared<Rete::Symbol_Variable>(Rete::Symbol_Variable::First), *$4, make_shared<Rete::Symbol_Variable>(*$2 == *$5 ? Rete::Symbol_Variable::First : Rete::Symbol_Variable::Third)))), Rete::Variable_Indices({{std::make_pair(*$2, Rete::WME_Token_Index(0, 0, 0)), std::make_pair(*$5, Rete::WME_Token_Index(0, 0, 2))}})); delete $2; delete $4; delete $5; }
  | '(' VARIABLE '^' VARIABLE symbol_constant ')' { $$ = Rete_Node_Ptr_and_Variables(Rete::Rete_Node_Ptr(agent.make_filter(Rete::WME(make_shared<Rete::Symbol_Variable>(Rete::Symbol_Variable::First), make_shared<Rete::Symbol_Variable>(*$2 == *$4 ? Rete::Symbol_Variable::First : Rete::Symbol_Variable::Second), *$5))), Rete::Variable_Indices({{std::make_pair(*$2, Rete::WME_Token_Index(0, 0, 0)), std::make_pair(*$4, Rete::WME_Token_Index(0, 0, 1))}})); delete $2; delete $4; delete $5; }
  | '(' VARIABLE '^' VARIABLE VARIABLE ')'  { $$ = Rete_Node_Ptr_and_Variables(Rete::Rete_Node_Ptr(agent.make_filter(Rete::WME(make_shared<Rete::Symbol_Variable>(Rete::Symbol_Variable::First), make_shared<Rete::Symbol_Variable>(*$2 == *$4 ? Rete::Symbol_Variable::First : Rete::Symbol_Variable::Second), make_shared<Rete::Symbol_Variable>(*$2 == *$5 ? Rete::Symbol_Variable::First : *$4 == *$5 ? Rete::Symbol_Variable::Second : Rete::Symbol_Variable::Third)))), Rete::Variable_Indices({{std::make_pair(*$2, Rete::WME_Token_Index(0, 0, 0)), std::make_pair(*$4, Rete::WME_Token_Index(0, 0, 1)), std::make_pair(*$5, Rete::WME_Token_Index(0, 0, 2))}})); delete $2; delete $4; delete $5; }
  ;
symbol:
  symbol_constant { $$ = $1; }
  | identifier { $$ = $1; }
  ;
identifier:
  '@' STRING { $$ = new Rete::Symbol_Ptr_C(make_shared<Rete::Symbol_Identifier>(*$2)); delete $2; }
  ;
symbol_constant:
  FLOAT { $$ = new Rete::Symbol_Ptr_C(make_shared<Rete::Symbol_Constant_Float>($1)); }
  | INT { $$ = new Rete::Symbol_Ptr_C(make_shared<Rete::Symbol_Constant_Int>($1)); }
  | string_or_literal { $$ = new Rete::Symbol_Ptr_C(make_shared<Rete::Symbol_Constant_String>(*$1)); delete $1; }
  ;
number:
  INT { $$ = double($1); }
  | FLOAT { $$ = $1; }
  ;
string_or_literal:
  STRING { $$ = $1; }
  | literal { $$ = $1; }
  ;
literal:
  '|' literal_parts '|' { $$ = $2; }
  ;
literal_parts:
  literal_parts STRING_PART_C { $$ = $1; *$$ += $2; }
  | literal_parts STRING_PART_S { $$ = $1; *$$ += *$2; delete $2; }
  | STRING_PART_C { $$ = new string; *$$ += $1; }
  | STRING_PART_S { $$ = $1; }
  ;

%%

#include "rete_parser.cxx"
