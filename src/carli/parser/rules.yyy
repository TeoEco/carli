%output "rules.tab.cpp"
%defines "rules.tab.hh"
%name-prefix "rete"
%define api.pure full
%error-verbose
%locations

%lex-param { yyscan_t yyscanner }
%parse-param { yyscan_t yyscanner }
%parse-param { Carli::Agent &agent }
%parse-param { const std::string &filename }
%parse-param { const std::string &source_path }

%code requires {
#ifndef YY_TYPEDEF_YY_SCANNER_T
#define YY_TYPEDEF_YY_SCANNER_T
typedef void *yyscan_t;
#endif
}

%code {
#include "lex.rete.hh"

static volatile sig_atomic_t g_rete_exit = false;

static void reteerror(const YYLTYPE * const /*yylloc*/, yyscan_t const yyscanner, Rete::Rete_Agent &/*agent*/, const std::string &filename, const std::string &/*source_path*/, const char *msg) {
  if(filename.empty())
    cout << "rete-parse error: " << msg << endl;
  else
    cout << "rete-parse error " << filename << '(' << reteget_lineno(yyscanner) << "): " << msg << endl;
}
}

%{
#define YY_NO_UNISTD_H 1
#include <csignal>
#include <cstdio>
#include <sstream>
#include "rete_parser.h"

using namespace std;

namespace Rete {

  static unordered_map<string, shared_ptr<tuple<double, double, bool>>> * Flags(const string &flag, const shared_ptr<tuple<double, double, bool>> &value, std::unordered_map<std::string, std::shared_ptr<std::tuple<double, double, bool>>> * flags = nullptr) {
    if(!flags)
      flags = new std::unordered_map<std::string, std::shared_ptr<std::tuple<double, double, bool>>>;
    (*flags)[flag] = value;
    return flags;
  }

  static vector<Parser_Variable> Variables() {
    vector<Parser_Variable> rv;
    return rv;
  }
  static vector<Parser_Variable> Variables(const Parser_Variable &variable) {
    vector<Parser_Variable> rv;
    rv.push_back(variable);
    return rv;
  }
  static pair<Rete::Rete_Node_Ptr, vector<Parser_Variable>> *
  Rete_Node_Ptr_and_Variables(const Rete::Rete_Node_Ptr &rete_node, const vector<Parser_Variable> &variables) {
    return new pair<Rete::Rete_Node_Ptr, vector<Parser_Variable>>(rete_node, variables);
  }

  static Rete::WME_Token_Index find_index(const std::vector<Parser_Variable> &variables, const std::string &name) {
    for(const auto &variable : variables) {
      for(const auto &ni : variable.name_index) {
        if(!ni.second.existential && ni.first == name)
          return ni.second;
      }
    }
    return Rete::WME_Token_Index(-1, -1, -1);
  }

  static Rete::WME_Bindings join_bindings(const std::vector<Parser_Variable> &lhs,
                                          const std::vector<Parser_Variable> &rhs)
  {
    Rete::WME_Bindings bindings;
    unordered_set<string> joined;
    for(const Parser_Variable &lvar : lhs) {
      for(const auto &lni : lvar.name_index) {
        if(!lni.second.existential && !lni.first.empty() && joined.find(lni.first) == joined.end()) {
          for(const Parser_Variable &rvar : rhs) {
            for(const auto &rni : rvar.name_index) {
              if(!rni.second.existential && lni.first == rni.first) {
                bindings.insert(Rete::WME_Binding(lni.second, rni.second));
                joined.insert(lni.first);
                goto DONE_JOINING;
              }
            }
          }
        }
        DONE_JOINING:
          ;
      }
    }
    return bindings;
  }

  static Rete::Variable_Indices_Ptr_C variables_to_indices(const vector<Parser_Variable> &variables) {
    const auto indices = std::make_shared<Rete::Variable_Indices>();
    for(const auto &variable : variables) {
      for(const auto &ni : variable.name_index) {
        if(ni.first.empty())
          continue;
        indices->insert(ni);
      }
    }
    return indices;
  }

  static vector<Parser_Variable> merge_variables(const vector<Parser_Variable> &lhs, const int64_t &lhs_size, const int64_t &lhs_token_size, const vector<Parser_Variable> &rhs, const bool &existential) {
    vector<Parser_Variable> variables(lhs);
    variables.reserve(variables.size() + rhs.size());
    for(const Parser_Variable &var_ : rhs) {
      Parser_Variable var(var_);
      for(auto &ni : var.name_index) {
        for(const Parser_Variable &existing_var : variables) {
          for(const auto &existing_ni : existing_var.name_index) {
            if(!existing_ni.second.existential && existing_ni.first == ni.first) {
              ni.first.clear();
              goto VAR_FOUND;
            }
          }
        }
        VAR_FOUND:
        ni.second.rete_row += lhs_size;
        ni.second.token_row += lhs_token_size;
        ni.second.existential = ni.second.existential | existential;
          ;
      }
      variables.push_back(var);
    }
    return variables;
  }

}

%}

%union {
  char cval;
  const char *csval;
  Rete::Parser_Flag *flag_ptr;
  double fval;
  int64_t ival;
  std::list<std::string> *slist;
  std::string *sval;
  Rete::Parser_Rete_Node *rete_node_ptr;
  Rete::Parser_Rule *rule_ptr;
  Rete::Symbol_Ptr_C *symbol_ptr;
  Rete::Rete_Predicate::Predicate predicate;
}

%token <csval> ARROW_RIGHT
%token <csval> ASSIGNMENT
%token <csval> COMMAND_EXCISE
%token <csval> COMMAND_EXCISE_ALL
%token <csval> COMMAND_EXIT
%token <csval> COMMAND_INSERT_WME
%token <csval> COMMAND_REMOVE_WME
%token <csval> COMMAND_SET_TOTAL_STEP_COUNT
%token <csval> COMMAND_SOURCE
%token <csval> COMMAND_SP
%token <csval> EXISTENTIAL_MATCH
%token <csval> FLAG_CREATION_TIME
%token <csval> FLAG_FEATURE
%token <fval> FLOAT
%token <ival> INT
%token <sval> NODE_TYPE
%token <sval> STRING
%token <cval> STRING_PART_C
%token <sval> STRING_PART_S
%token <sval> VARIABLE
%token <predicate> PREDICATE

%type <flag_ptr> flags
%type <fval> number
%type <rete_node_ptr> final_conditions conditions condition_group condition_type condition
%type <rule_ptr> rule
%type <sval> string_or_literal literal literal_parts
%type <symbol_ptr> symbol identifier symbol_constant

%%
commands:
  | commands command { /*cerr << "Read in rule on line " << reteget_lineno(yyscanner) << endl;*/ }
  ;
command:
  COMMAND_EXCISE STRING { agent.excise_rule(*$2, true);
                          delete $2; }
  | COMMAND_EXCISE_ALL { agent.excise_all(); }
  | COMMAND_EXIT { g_rete_exit = true;
                   YYACCEPT; }
  | COMMAND_INSERT_WME '(' symbol '^' symbol symbol ')' { const auto wme = make_shared<Rete::WME>(*$3, *$5, *$6);
                                                          agent.insert_wme(wme);
                                                          delete $3;
                                                          delete $5;
                                                          delete $6; }
  | COMMAND_REMOVE_WME '(' symbol '^' symbol symbol ')' { const auto wme = make_shared<Rete::WME>(*$3, *$5, *$6);
                                                          agent.remove_wme(wme);
                                                          delete $3;
                                                          delete $5;
                                                          delete $6; }
  | COMMAND_SET_TOTAL_STEP_COUNT INT { agent.set_total_step_count($2); }
  | COMMAND_SOURCE string_or_literal { const int rv = rete_parse_file(agent, *$2, source_path);
                                       if(rv) {
                                         ostringstream oss;
                                         oss << "Error sourcing '" << *$2 << "'.";
                                         reteerror(&yylloc, yyscanner, agent, filename, source_path, oss.str().c_str());
                                         delete $2;
                                         YYABORT;
                                       }
                                       delete $2;
                                       if(g_rete_exit) {
                                         YYACCEPT;
                                       } }
  | COMMAND_SP rule { const auto &parent =                            get<0>(*$2).first;
                      const auto &variable_names =                    get<0>(*$2).second;
                      const string &name =                            get<1>(*$2);
                      const int64_t &timestamp =              *get<0>(get<2>(*$2));
                      const int64_t &q_value_depth =   get<0>(*get<1>(get<2>(*$2)));
                      const string &node_type =        get<1>(*get<1>(get<2>(*$2)));
                      const string &parent_node_name = get<2>(*get<1>(get<2>(*$2)));
                      const auto &feature =            get<3>(*get<1>(get<2>(*$2)));
                      const auto &q_value_value =                     get<3>(*$2);
                      const auto variable_indices = variables_to_indices(variable_names);
                      const auto parent_action = agent.get_rule(parent_node_name);

                      const auto existing = agent.unname_rule(name, true);
                      if(existing) {
                        parent->suppress_destruction(true);
                        existing->destroy(agent);
                      }

                      Rete::Rete_Action_Ptr new_action;
                      if(node_type.empty()) {
                        /// Non-RL node
                        auto node = agent.make_action_retraction(name, true,
                                                                 [](const Rete::Rete_Action &action, const Rete::WME_Token &wme_vector) {
                                                                   cout << wme_vector << "->" << action.get_name() << endl;
                                                                 }, [](const Rete::Rete_Action &action, const Rete::WME_Token &wme_vector) {
                                                                   cout << wme_vector << "<-" << action.get_name() << endl;
                                                                 }, parent, make_shared<Rete::Variable_Indices>());
                      }
                      else {
                        if(feature) {
                          auto test_node_rightmost = parent;
                          bool test_node_rightmost_existential = false;
                          while(test_node_rightmost->get_bindings()) {
                            test_node_rightmost_existential |= dynamic_cast<Rete::Rete_Existential_Join *>(test_node_rightmost.get()) || dynamic_cast<Rete::Rete_Negation_Join *>(test_node_rightmost.get());
                            test_node_rightmost = test_node_rightmost->parent_right();
                          }

                          /// Fill in Feature values / predicate tests
                          if(const auto feature_e = dynamic_cast<Carli::Feature_Enumerated<Carli::Feature> *>(feature)) {
                            /// TODO: Handle variable-to-variable relations
                            if(const auto predicate = dynamic_cast<Rete::Rete_Predicate *>(test_node_rightmost.get())) {
                              const auto rhs = predicate->get_rhs().get();
                              const auto symbol_i = dynamic_cast<const Rete::Symbol_Constant_Int *>(rhs);
                              assert(symbol_i);
                              feature_e->value = symbol_i->value;
                            }
                            else if(dynamic_cast<Rete::Rete_Existential_Join *>(parent.get()))
                              feature_e->value = true;
                            else if(dynamic_cast<Rete::Rete_Negation_Join *>(parent.get()))
                              feature_e->value = false;
                            else {
                              reteerror(&yylloc, yyscanner, agent, filename, source_path, "Error reading enumerated feature value / predicate test.");
                              YYABORT;
                            }
                          }
                          else if(const auto feature_r = dynamic_cast<Carli::Feature_Ranged<Carli::Feature> *>(feature)) {
                            const auto &predicate = dynamic_cast<Rete::Rete_Predicate &>(*test_node_rightmost);
                            feature_r->upper = predicate.get_predicate() == Rete::Rete_Predicate::GTE;
                          }
                          else {
                            reteerror(&yylloc, yyscanner, agent, filename, source_path, "Error reading enumerated/ranged feature value / predicate test.");
                            YYABORT;
                          }

                          /// Determine Feature axes
                          if(const auto predicate = dynamic_cast<const Rete::Rete_Predicate *>(test_node_rightmost.get())) {
                            feature->axis = predicate->get_lhs_index();
                            feature->axis.existential = test_node_rightmost_existential;
                          }
                          else if(dynamic_cast<Rete::Rete_Existential_Join *>(parent.get()) ||
                                  dynamic_cast<Rete::Rete_Negation_Join *>(parent.get()))
                          {
                            feature->axis = Rete::WME_Token_Index(-1, -1, -1);
                          }
                          else {
                            Rete::Rete_Node_Ptr test_node = parent;
                            const Rete::Rete_Filter * filter_node = dynamic_cast<const Rete::Rete_Filter *>(test_node->parent_right().get());
                            while(!filter_node) {
                              test_node = test_node->parent_right();
                              filter_node = dynamic_cast<const Rete::Rete_Filter *>(test_node->parent_right().get());
                            }

                            if(const auto bindings = test_node->get_bindings()) {
                              for(const auto binding : *bindings) {
                                if(binding.second == Rete::WME_Token_Index(0, 0, 0)) {
                                  feature->axis = binding.first;
                                  goto AXIS_FOUND;
                                }
                              }
                            }
                            reteerror(&yylloc, yyscanner, agent, filename, source_path, "Error determining Feature axis.");
                            YYABORT;
                            AXIS_FOUND:
                              ;
                          }

                          if(feature->get_depth() > 1) {
                            const auto predicate = dynamic_cast<const Rete::Rete_Predicate *>(parent.get());
                            assert(predicate);
                            if(predicate) {
                              auto ancestor = parent_action;
                              auto ancestor_prev = ancestor;
                              assert(ancestor && dynamic_cast<const Carli::Node *>(ancestor->data.get())->q_value_fringe->feature);
                              while(ancestor && dynamic_cast<const Carli::Node *>(ancestor->data.get())->q_value_fringe->feature &&
                                    ancestor->get_token_size() > predicate->get_lhs_index().token_row)
                              {
                                ancestor_prev = ancestor;
                                ancestor = dynamic_cast<const Carli::Node *>(ancestor->data.get())->parent_action.lock();
                              }

                              assert(ancestor);
                              if(ancestor) {
                                const auto ancestor_node = dynamic_cast<const Carli::Node *>(ancestor_prev->data.get());
                                assert(ancestor_node);
                                assert(ancestor_node->q_value_fringe);
                                assert(ancestor_node->q_value_fringe->feature);
                                feature->bindings = ancestor_node->q_value_fringe->feature->bindings;
                                feature->conditions = ancestor_node->q_value_fringe->feature->conditions;
                              }
                              else
                                feature->bindings.insert(std::make_pair(predicate->get_lhs_index(), Rete::WME_Token_Index(-1, -1, -1)));
                            }
                          }
                          else {
                            if(parent->get_bindings()) {
                              feature->bindings = *parent->get_bindings();
                              feature->conditions = parent->parent_right()->get_filter_wmes();
                            }
                            if(auto predicate = dynamic_cast<const Rete::Rete_Predicate *>(parent.get()))
                              feature->bindings.insert(std::make_pair(predicate->get_lhs_index(), Rete::WME_Token_Index(-1, -1, -1)));
                          }

                          if(feature->axis.rete_row != -1 && parent->get_bindings()) {
                            if(feature->axis.existential && dynamic_cast<const Carli::Feature_Ranged_Data *>(feature)) {
                              reteerror(&yylloc, yyscanner, agent, filename, source_path, "Refineable feature illegally declared existential.");
                              YYABORT;
                            }
                            feature->axis.rete_row += parent->parent_left()->get_size();
                            feature->axis.token_row += parent->parent_left()->get_token_size();
                          }
                          feature->indices = variable_indices;

                          //std::cerr << "LHS" << feature->axis << ' ' << *variable_indices << std::endl;
                        }

                        /// Make the new action
                        if(node_type == "split") {
                          const auto new_q_value_weight = new Carli::Q_Value(q_value_value, Carli::Q_Value::Type::SPLIT, q_value_depth, feature, timestamp);
                          const auto new_q_value_fringe = new Carli::Q_Value(Carli::Q_Value::Token() /** HACK: Not stored in written rules. */, Carli::Q_Value::Type::FRINGE, q_value_depth, feature, timestamp);
                          new_action = agent.make_standard_action(parent, name, true, variable_indices);
                          auto new_action_data = std::make_shared<Carli::Node_Split>(agent, parent_action, new_action, new_q_value_weight, new_q_value_fringe);
                          new_action->data = new_action_data;
                        }
                        else if(node_type == "unsplit") {
                          const auto new_q_value_weight = new Carli::Q_Value(q_value_value, Carli::Q_Value::Type::UNSPLIT, q_value_depth, feature, timestamp);
                          const auto new_q_value_fringe = new Carli::Q_Value(Carli::Q_Value::Token() /** HACK: Not stored in written rules. */, Carli::Q_Value::Type::FRINGE, q_value_depth, feature, timestamp);
                          new_action = agent.make_standard_action(parent, name, true, variable_indices);
                          auto new_action_data = std::make_shared<Carli::Node_Unsplit>(agent, parent_action, new_action, new_q_value_weight, new_q_value_fringe);
                          new_action->data = new_action_data;
                        }
                        else {
                          assert(node_type == "fringe");
                          const auto new_q_value_fringe = new Carli::Q_Value(q_value_value, Carli::Q_Value::Type::FRINGE, q_value_depth, feature, timestamp);
                          new_action = agent.make_standard_action(parent, name, true, variable_indices);
                          auto new_action_data = std::make_shared<Carli::Node_Fringe>(agent, parent_action, new_action, nullptr, new_q_value_fringe);
                          new_action->data = new_action_data;
                          if(parent_action) {
                            auto &parent_data = dynamic_cast<Carli::Node_Unsplit &>(*parent_action->data);
                            parent_data.fringe_values[feature].values.push_back(new_action_data);
                          }
                          else {
                            reteerror(&yylloc, yyscanner, agent, filename, source_path, "Ancestral relationship specified in :feature fringe not found.");
                            YYABORT;
                          }
                        }

                        if(parent_action && parent->parent_left() != parent_action->parent_left()) {
                          if(!get_Option_Ranged<bool>(Options::get_global(), "rete-disable-node-sharing")) {
                            reteerror(&yylloc, yyscanner, agent, filename, source_path, "Illegal ancestral relationship specified in :feature.");
                            YYABORT;
                          }
                        }
                      }

                      parent->suppress_destruction(false);
                      delete $2; }
  ;
rule:
  '{' STRING flags final_conditions '}' { if(!get<0>(*$3))
                                            get<0>(*$3) = make_shared<int64_t>(agent.get_total_step_count());
                                          if(!get<1>(*$3))
                                            get<1>(*$3) = make_shared<tuple<int64_t, string, string, Carli::Feature *>>();
                                          $$ = new tuple<pair<Rete::Rete_Node_Ptr, vector<Rete::Parser_Variable>>, string, tuple<shared_ptr<int64_t>, shared_ptr<tuple<int64_t, string, string, Carli::Feature *>>>, Carli::Q_Value::Token>(*$4, *$2, *$3, Carli::Q_Value::Token());
                                          delete $2;
                                          delete $3;
                                          delete $4; }
  | '{' STRING flags final_conditions ARROW_RIGHT ASSIGNMENT number number number number INT '}'
        { if(!get<0>(*$3))
            get<0>(*$3) = make_shared<int64_t>(agent.get_total_step_count());
          if(!get<1>(*$3))
            get<1>(*$3) = make_shared<tuple<int64_t, string, string, Carli::Feature *>>();
          $$ = new tuple<pair<Rete::Rete_Node_Ptr, vector<Rete::Parser_Variable>>, string, tuple<shared_ptr<int64_t>, shared_ptr<tuple<int64_t, string, string, Carli::Feature *>>>, Carli::Q_Value::Token>(*$4, *$2, *$3, Carli::Q_Value::Token($7, $8, $9, $10, $11));
          delete $2;
          delete $3;
          delete $4; }
  | '{' STRING flags final_conditions ARROW_RIGHT ASSIGNMENT number '}'
        { if(!get<0>(*$3))
            get<0>(*$3) = make_shared<int64_t>(agent.get_total_step_count());
          if(!get<1>(*$3))
            get<1>(*$3) = make_shared<tuple<int64_t, string, string, Carli::Feature *>>();
          $$ = new tuple<pair<Rete::Rete_Node_Ptr, vector<Rete::Parser_Variable>>, string, tuple<shared_ptr<int64_t>, shared_ptr<tuple<int64_t, string, string, Carli::Feature *>>>, Carli::Q_Value::Token>(*$4, *$2, *$3, Carli::Q_Value::Token($7, 0.0, 0.0, 0.0, 0));
          delete $2;
          delete $3;
          delete $4; }
  ;
flags:
  /* :feature q_value->depth [feature->depth feature->lower_bound feature->upper_bound] */
  { $$ = new tuple<shared_ptr<int64_t>, shared_ptr<tuple<int64_t, string, string, Carli::Feature *>>>; }
  | flags FLAG_CREATION_TIME INT { if(get<0>(*$1)) {
                                     reteerror(&yylloc, yyscanner, agent, filename, source_path, "Flag :creation-time set more than once.");
                                     YYABORT;
                                   }
                                   $$ = $1;
                                   get<0>(*$$) = make_shared<int64_t>($3); }
  | flags FLAG_FEATURE INT NODE_TYPE STRING INT FLOAT FLOAT { if(get<1>(*$1)) {
                                                                reteerror(&yylloc, yyscanner, agent, filename, source_path, "Flag :feature set more than once.");
                                                                YYABORT;
                                                              }
                                                              $$ = $1;
                                                              get<1>(*$$) = make_shared<tuple<int64_t, string, string, Carli::Feature *>>($3, *$4, *$5, new Carli::Feature_Ranged<Carli::Feature>(vector<Rete::WME>() /*FIXUP Later*/, Rete::WME_Bindings() /*FIXUP later*/, Rete::WME_Token_Index() /*FIXUP later*/, nullptr /*FIXUP later*/, $7, $8, $6, false /*FIXUP later*/, false));
                                                              delete $4;
                                                              delete $5; }
  | flags FLAG_FEATURE INT NODE_TYPE STRING INT INT INT { if(get<1>(*$1)) {
                                                            reteerror(&yylloc, yyscanner, agent, filename, source_path, "Flag :feature set more than once.");
                                                            YYABORT;
                                                          }
                                                          $$ = $1;
                                                          get<1>(*$$) = make_shared<tuple<int64_t, string, string, Carli::Feature *>>($3, *$4, *$5, new Carli::Feature_Ranged<Carli::Feature>(vector<Rete::WME>() /*FIXUP Later*/, Rete::WME_Bindings() /*FIXUP later*/, Rete::WME_Token_Index() /*FIXUP later*/, nullptr /*FIXUP later*/, $7, $8, $6, false /*FIXUP later*/, true));
                                                          delete $4;
                                                          delete $5; }
  | flags FLAG_FEATURE INT NODE_TYPE STRING { if(get<1>(*$1)) {
                                                reteerror(&yylloc, yyscanner, agent, filename, source_path, "Flag :feature set more than once.");
                                                YYABORT;
                                              }
                                              $$ = $1;
                                              if($3 > 1)
                                                get<1>(*$$) = make_shared<tuple<int64_t, string, string, Carli::Feature *>>($3, *$4, *$5, new Carli::Feature_Enumerated<Carli::Feature>(vector<Rete::WME>() /*FIXUP Later*/, Rete::WME_Bindings() /*FIXUP later*/, Rete::WME_Token_Index() /*FIXUP later*/, nullptr /*FIXUP later*/, 0 /*FIXUP later*/));
                                              else
                                                get<1>(*$$) = make_shared<tuple<int64_t, string, string, Carli::Feature *>>($3, *$4, *$5, nullptr);
                                              delete $4;
                                              delete $5; }
  ;
final_conditions:
  conditions { $$ = $1; }
  | '+' conditions { $$ = Rete_Node_Ptr_and_Variables(Rete::Rete_Node_Ptr(agent.make_existential($2->first)), Rete::Variables()); delete $2; }
  | '-' conditions { $$ = Rete_Node_Ptr_and_Variables(Rete::Rete_Node_Ptr(agent.make_negation($2->first)), Rete::Variables()); delete $2; }
  | final_conditions EXISTENTIAL_MATCH condition_type { $$ = Rete_Node_Ptr_and_Variables(Rete::Rete_Node_Ptr(agent.make_existential_join(Rete::WME_Bindings(), true, $1->first, $3->first)), $1->second);
                                                        delete $1;
                                                        delete $3; }
  ;
conditions:
  conditions condition_type { const vector<Rete::Parser_Variable> variables(merge_variables($1->second, $1->first->get_size(), $1->first->get_token_size(), $2->second, false));
                              $$ = Rete_Node_Ptr_and_Variables(Rete::Rete_Node_Ptr(agent.make_join(join_bindings($1->second, $2->second), $1->first, $2->first)), variables);
                              delete $1;
                              delete $2; }
  | conditions '+' condition_type { const vector<Rete::Parser_Variable> variables(merge_variables($1->second, $1->first->get_size(), $1->first->get_token_size(), $3->second, true));
                                    $$ = Rete_Node_Ptr_and_Variables(Rete::Rete_Node_Ptr(agent.make_existential_join(join_bindings($1->second, $3->second), false, $1->first, $3->first)), variables);
                                    delete $1;
                                    delete $3; }
  | conditions '-' condition_type { const vector<Rete::Parser_Variable> variables(merge_variables($1->second, $1->first->get_size(), $1->first->get_token_size(), $3->second, true));
                                    $$ = Rete_Node_Ptr_and_Variables(Rete::Rete_Node_Ptr(agent.make_negation_join(join_bindings($1->second, $3->second), $1->first, $3->first)), variables);
                                    delete $1;
                                    delete $3; }
  | conditions '(' VARIABLE PREDICATE symbol_constant ')' { const auto lhs_index = find_index($1->second, *$3);
                                                            if(lhs_index.column > 2) {
                                                              reteerror(&yylloc, yyscanner, agent, filename, source_path, "Unbound variable tested by predicate.");
                                                              YYABORT;
                                                            }
                                                            $$ = Rete_Node_Ptr_and_Variables(Rete::Rete_Node_Ptr(agent.make_predicate_vc($4, lhs_index, *$5, $1->first)), $1->second);
                                                            delete $1;
                                                            delete $3;
                                                            delete $5; }
  | conditions '(' VARIABLE PREDICATE VARIABLE ')' { const auto lhs_index = find_index($1->second, *$3);
                                                     const auto rhs_index = find_index($1->second, *$5);
                                                     if(lhs_index.column > 2 || rhs_index.column > 2) {
                                                       reteerror(&yylloc, yyscanner, agent, filename, source_path, "Unbound variable tested by predicate.");
                                                       YYABORT;
                                                     }
                                                     $$ = Rete_Node_Ptr_and_Variables(Rete::Rete_Node_Ptr(agent.make_predicate_vv($4, lhs_index, rhs_index, $1->first)), $1->second);
                                                     delete $1;
                                                     delete $3;
                                                     delete $5; }
  | condition_type { $$ = $1; }
  ;
condition_group:
  '{' final_conditions '}' { $$ = $2; }
  ;
condition_type:
  condition { $$ = $1; }
  | condition_group { $$ = $1; }
  ;
condition:
  '(' VARIABLE '^' symbol_constant symbol_constant ')' { $$ = Rete_Node_Ptr_and_Variables(Rete::Rete_Node_Ptr(agent.make_filter(Rete::WME(make_shared<Rete::Symbol_Variable>(Rete::Symbol_Variable::First), *$4, *$5))), Variables(Rete::Parser_Variable(*$2, "", ""))); delete $2; delete $4; delete $5; }
  | '(' VARIABLE '^' symbol_constant VARIABLE ')'  { $$ = Rete_Node_Ptr_and_Variables(Rete::Rete_Node_Ptr(agent.make_filter(Rete::WME(make_shared<Rete::Symbol_Variable>(Rete::Symbol_Variable::First), *$4, make_shared<Rete::Symbol_Variable>(*$2 == *$5 ? Rete::Symbol_Variable::First : Rete::Symbol_Variable::Third)))), Variables(Rete::Parser_Variable(*$2, "", *$5))); delete $2; delete $4; delete $5; }
  | '(' VARIABLE '^' VARIABLE symbol_constant ')' { $$ = Rete_Node_Ptr_and_Variables(Rete::Rete_Node_Ptr(agent.make_filter(Rete::WME(make_shared<Rete::Symbol_Variable>(Rete::Symbol_Variable::First), make_shared<Rete::Symbol_Variable>(*$2 == *$4 ? Rete::Symbol_Variable::First : Rete::Symbol_Variable::Second), *$5))), Variables(Rete::Parser_Variable(*$2, *$4, ""))); delete $2; delete $4; delete $5; }
  | '(' VARIABLE '^' VARIABLE VARIABLE ')'  { $$ = Rete_Node_Ptr_and_Variables(Rete::Rete_Node_Ptr(agent.make_filter(Rete::WME(make_shared<Rete::Symbol_Variable>(Rete::Symbol_Variable::First), make_shared<Rete::Symbol_Variable>(*$2 == *$4 ? Rete::Symbol_Variable::First : Rete::Symbol_Variable::Second), make_shared<Rete::Symbol_Variable>(*$2 == *$5 ? Rete::Symbol_Variable::First : *$4 == *$5 ? Rete::Symbol_Variable::Second : Rete::Symbol_Variable::Third)))), Variables(Rete::Parser_Variable(*$2, *$4, *$5))); delete $2; delete $4; delete $5; }
  ;
symbol:
  symbol_constant { $$ = $1; }
  | identifier { $$ = $1; }
  ;
identifier:
  '@' STRING { $$ = new Rete::Symbol_Ptr_C(make_shared<Rete::Symbol_Identifier>(*$2)); delete $2; }
  ;
symbol_constant:
  FLOAT { $$ = new Rete::Symbol_Ptr_C(make_shared<Rete::Symbol_Constant_Float>($1)); }
  | INT { $$ = new Rete::Symbol_Ptr_C(make_shared<Rete::Symbol_Constant_Int>($1)); }
  | string_or_literal { $$ = new Rete::Symbol_Ptr_C(make_shared<Rete::Symbol_Constant_String>(*$1)); delete $1; }
  ;
number:
  INT { $$ = double($1); }
  | FLOAT { $$ = $1; }
  ;
string_or_literal:
  STRING { $$ = $1; }
  | literal { $$ = $1; }
  ;
literal:
  '|' literal_parts '|' { $$ = $2; }
  ;
literal_parts:
  literal_parts STRING_PART_C { $$ = $1; *$$ += $2; }
  | literal_parts STRING_PART_S { $$ = $1; *$$ += *$2; delete $2; }
  | STRING_PART_C { $$ = new string; *$$ += $1; }
  | STRING_PART_S { $$ = $1; }
  ;

%%

#include "rete_parser.cxx"
