%output "rules.tab.cpp"
%defines "rules.tab.hh"
%name-prefix "rete"
%define api.pure full
%error-verbose
%locations

%lex-param { yyscan_t yyscanner }
%parse-param { yyscan_t yyscanner }
%parse-param { Carli::Agent &agent }
%parse-param { const std::string &filename }
%parse-param { const std::string &source_path }
%parse-param { Grandparent_to_UFV &gufv }

%code requires {
#ifndef YY_TYPEDEF_YY_SCANNER_T
#define YY_TYPEDEF_YY_SCANNER_T
typedef void *yyscan_t;
#endif
typedef std::unordered_map<Rete::Rete_Node_Ptr, std::pair<Carli::Node_Unsplit_Ptr, Carli::Fringe_Values>> Grandparent_to_UFV;
}

%code {
#include "lex.rete.hh"

static volatile sig_atomic_t g_rete_exit = false;

static void reteerror(const YYLTYPE * const /*yylloc*/, yyscan_t const yyscanner, Rete::Rete_Agent &/*agent*/, const std::string &filename, const std::string &/*source_path*/, Grandparent_to_UFV &/*gufv*/, const char *msg) {
  if(filename.empty())
    cout << "rete-parse error: " << msg << endl;
  else
    cout << "rete-parse error " << filename << '(' << reteget_lineno(yyscanner) << "): " << msg << endl;
}
}

%{
#define YY_NO_UNISTD_H 1
#include <csignal>
#include <cstdio>
#include <sstream>
#include "rete_parser.h"

using namespace std;

static unordered_map<string, shared_ptr<tuple<double, double, bool>>> * Flags(const string &flag, const shared_ptr<tuple<double, double, bool>> &value, std::unordered_map<std::string, std::shared_ptr<std::tuple<double, double, bool>>> * flags = nullptr) {
  if(!flags)
    flags = new std::unordered_map<std::string, std::shared_ptr<std::tuple<double, double, bool>>>;
  (*flags)[flag] = value;
  return flags;
}

static array<string, 3> Variable(const string &s0, const string &s1, const string &s2) {
  array<string, 3> variable;
  variable[0] = s0;
  variable[1] = s1;
  variable[2] = s2;
  return variable;
}
static vector<array<string, 3>> Variables() {
  vector<array<string, 3>> rv;
  return rv;
}
static vector<array<string, 3>> Variables(const array<string, 3> &variable) {
  vector<array<string, 3>> rv;
  rv.push_back(variable);
  return rv;
}
static pair<Rete::Rete_Node_Ptr, vector<array<string, 3>>> *
Rete_Node_Ptr_and_Variables(const Rete::Rete_Node_Ptr &rete_node, const vector<array<string, 3>> &variables) {
  return new pair<Rete::Rete_Node_Ptr, vector<array<string, 3>>>(rete_node, variables);
}

static Rete::WME_Token_Index find_index(const std::vector<std::array<std::string, 3>> &variables, const std::string &variable) {
  for(size_t i = 0; i != variables.size(); ++i) {
    for(uint8_t ii = 0; ii != 3; ++ii) {
      if(variables[i][ii] == variable)
        return Rete::WME_Token_Index(i, ii);
    }
  }
  return Rete::WME_Token_Index(size_t(-1), uint8_t(-1));
}

static Rete::WME_Bindings join_bindings(const std::vector<std::array<std::string, 3>> &lhs,
                                        const std::vector<std::array<std::string, 3>> &rhs)
{
  Rete::WME_Bindings bindings;
  unordered_set<string> joined;
  for(size_t i = 0; i != lhs.size(); ++i) {
    for(uint8_t ii = 0; ii != 3; ++ii) {
      if(!lhs[i][ii].empty() && joined.find(lhs[i][ii]) == joined.end()) {
        for(size_t j = 0; j != rhs.size(); ++j) {
          for(uint8_t jj = 0; jj != 3; ++jj) {
            if(lhs[i][ii] == rhs[j][jj]) {
              bindings.insert(Rete::WME_Binding(Rete::WME_Token_Index(i, ii), Rete::WME_Token_Index(j, jj)));
              joined.insert(lhs[i][ii]);
              goto DONE_JOINING;
            }
          }
        }
      }
      DONE_JOINING:
        ;
    }
  }
  return bindings;
}

static Rete::Variable_Indices variables_to_indices(const vector<array<string, 3>> &variables) {
  Rete::Variable_Indices indices;
  for(size_t i = 0; i != variables.size(); ++i) {
    for(uint8_t ii = 0; ii != 3; ++ii) {
      if(!variables[i][ii].empty() && indices.find(variables[i][ii]) == indices.end())
        indices[variables[i][ii]] = Rete::WME_Token_Index(i, ii);
    }
  }
  return indices;
}

%}

%union {
  char cval;
  const char *csval;
  std::tuple<int64_t, std::string, Carli::Feature *> *flag_ptr;
  double fval;
  int64_t ival;
  std::string *sval;
  std::pair<Rete::Rete_Node_Ptr, std::vector<std::array<std::string, 3>>> *rete_node_ptr;
  std::tuple<std::pair<Rete::Rete_Node_Ptr, std::vector<std::array<std::string, 3>>>, std::string, std::tuple<int64_t, std::string, Carli::Feature *>> *rule_ptr;
  Rete::Symbol_Ptr_C *symbol_ptr;
  Rete::Rete_Predicate::Predicate predicate;
}

%token <csval> COMMAND_EXCISE
%token <csval> COMMAND_EXCISE_ALL
%token <csval> COMMAND_EXIT
%token <csval> COMMAND_INSERT_WME
%token <csval> COMMAND_REMOVE_WME
%token <csval> COMMAND_SOURCE
%token <csval> COMMAND_SP
%token <csval> FLAG_FEATURE
%token <fval> FLOAT
%token <ival> INT
%token <sval> NODE_TYPE
%token <sval> STRING
%token <cval> STRING_PART_C
%token <sval> STRING_PART_S
%token <sval> VARIABLE
%token <predicate> PREDICATE

%type <flag_ptr> flag
%type <rete_node_ptr> final_conditions conditions condition_group condition_type condition
%type <rule_ptr> rule
%type <symbol_ptr> symbol identifier symbol_constant
%type <sval> string_or_literal literal literal_parts

%%
commands:
  | commands command { /*cerr << "Read in rule on line " << reteget_lineno(yyscanner) << endl;*/ }
  ;
command:
  COMMAND_EXCISE STRING { agent.excise_rule(*$2, true);
                          delete $2; }
  | COMMAND_EXCISE_ALL { agent.excise_all(); }
  | COMMAND_EXIT { g_rete_exit = true;
                   YYACCEPT; }
  | COMMAND_INSERT_WME '(' symbol '^' symbol symbol ')' { const auto wme = make_shared<Rete::WME>(*$3, *$5, *$6);
                                                          agent.insert_wme(wme);
                                                          delete $3;
                                                          delete $5;
                                                          delete $6; }
  | COMMAND_REMOVE_WME '(' symbol '^' symbol symbol ')' { const auto wme = make_shared<Rete::WME>(*$3, *$5, *$6);
                                                          agent.remove_wme(wme);
                                                          delete $3;
                                                          delete $5;
                                                          delete $6; }
  | COMMAND_SOURCE string_or_literal { const int rv = rete_parse_file(agent, *$2, source_path);
                                       if(rv) {
                                         ostringstream oss;
                                         oss << "Error sourcing '" << *$2 << "'.";
                                         reteerror(&yylloc, yyscanner, agent, filename, source_path, gufv, oss.str().c_str());
                                         delete $2;
                                         YYABORT;
                                       }
                                       delete $2;
                                       if(g_rete_exit) {
                                         YYACCEPT;
                                       } }
  | COMMAND_SP rule { const auto &parent = get<0>(*$2).first;
                      const auto &variable_names = get<0>(*$2).second;
                      const string &name = get<1>(*$2);
                      const int64_t &q_value_depth = get<0>(get<2>(*$2));
                      const string &node_type = get<1>(get<2>(*$2));
                      const auto &feature = get<2>(get<2>(*$2));
                      const auto variable_indices = variables_to_indices(variable_names);

                      agent.get_agenda().lock();
                      const auto existing = agent.unname_rule(name, true);
                      if(existing) {
                        parent->suppress_destruction(true);
                        existing->destroy(agent);
                      }

                      Rete::Rete_Action_Ptr new_action;
                      if(node_type.empty()) {
                        /// Non-RL node
                        auto node = agent.make_action_retraction(name, true,
                                                                 [](const Rete::Rete_Action &action, const Rete::WME_Token &wme_vector) {
                                                                   cout << wme_vector << "->" << action.get_name() << endl;
                                                                 }, [](const Rete::Rete_Action &action, const Rete::WME_Token &wme_vector) {
                                                                   cout << wme_vector << "<-" << action.get_name() << endl;
                                                                 }, parent, Rete::Variable_Indices());
                      }
                      else {
                        if(feature) {
                          if(const auto feature_e = dynamic_cast<Carli::Feature_Enumerated<Carli::Feature> *>(feature)) {
                            /// TODO: Handle variable-to-variable relations
                            if(const auto predicate = dynamic_cast<Rete::Rete_Predicate *>(parent.get())) {
                              const auto rhs = predicate->get_rhs().get();
                              const auto symbol_i = dynamic_cast<const Rete::Symbol_Constant_Int *>(rhs);
                              assert(symbol_i);
                              feature_e->value = symbol_i->value;
                            }
                            else if(dynamic_cast<Rete::Rete_Existential_Join *>(parent.get()))
                              feature_e->value = true;
                            else if(dynamic_cast<Rete::Rete_Negation_Join *>(parent.get()))
                              feature_e->value = false;
                            else
                              abort();
                          }
                          else if(const auto feature_r = dynamic_cast<Carli::Feature_Ranged<Carli::Feature> *>(feature)) {
                            const auto &predicate = dynamic_cast<Rete::Rete_Predicate &>(*parent);
                            feature_r->upper = predicate.get_predicate() == Rete::Rete_Predicate::GTE;
                          }
                          else
                            abort();
                        }

                        Rete::Rete_Node_Ptr test_node = parent;
                        bool terminal = true;
                        if(node_type == "split") {
                          const auto filter = dynamic_cast<Rete::Rete_Filter *>(parent->parent_right().get());
                          bool terminal = true;
                          if(filter) {
                            const auto &wme = filter->get_wme();
                            terminal = !dynamic_cast<const Rete::Symbol_Variable *>(wme.symbols[0].get()) ||
                                       wme.symbols[0] != wme.symbols[1] || wme.symbols[0] != wme.symbols[2];
                          }

                          if(!terminal)
                            test_node = test_node->parent_left();
                        }
                        else if(node_type == "unsplit")
                          test_node = test_node->parent_left();

                        if(feature) {
                          if(const auto predicate = dynamic_cast<const Rete::Rete_Predicate *>(test_node.get()))
                            feature->axis = predicate->get_lhs_index();
                          else {
                            while(!dynamic_cast<const Rete::Rete_Filter *>(test_node->parent_right().get()))
                              test_node = test_node->parent_right();

                            if(const auto join = dynamic_cast<const Rete::Rete_Existential_Join *>(test_node.get())) {
                              for(const auto binding : join->get_bindings()) {
                                if(binding.second == Rete::WME_Token_Index(0, 0)) {
                                  feature->axis = binding.first;
                                  goto AXIS_FOUND;
                                }
                              }
                            }
                            else if(const auto join = dynamic_cast<const Rete::Rete_Negation_Join *>(test_node.get())) {
                              for(const auto binding : join->get_bindings()) {
                                if(binding.second == Rete::WME_Token_Index(0, 0)) {
                                  feature->axis = binding.first;
                                  goto AXIS_FOUND;
                                }
                              }
                            }
                            abort();
                            AXIS_FOUND:
                              ;
                          }
                        }

                        if(node_type == "split") {
                          const auto new_q_value = new Carli::Q_Value(0.0, Carli::Q_Value::Type::SPLIT, q_value_depth, feature);
                          new_action = agent.make_standard_action(parent, name, true, variable_indices);
                          auto new_action_data = std::make_shared<Carli::Node_Split>(agent, new_action, new_q_value, terminal);
                          new_action->data = new_action_data;
                        }
                        else if(node_type == "unsplit") {
                          new_action = agent.make_standard_action(parent, name, true, variable_indices);
                          auto new_action_data = std::make_shared<Carli::Node_Unsplit>(agent, new_action, q_value_depth, feature);
                          new_action->data = new_action_data;
                          gufv[test_node].first = new_action_data;
                        }
                        else {
                          assert(node_type == "fringe");
                          new_action = agent.make_standard_action(parent, name, true, variable_indices);
                          auto new_action_data = std::make_shared<Carli::Node_Fringe>(agent, new_action, q_value_depth, feature);
                          new_action->data = new_action_data;
                          gufv[test_node->parent_left()].second[feature].values.push_back(new_action_data);
                        }
                      }

                      parent->suppress_destruction(false);
                      agent.get_agenda().unlock();
                      agent.get_agenda().run();
                      delete $2; }
  ;
rule:
  '{' STRING final_conditions '}' { $$ = new tuple<std::pair<Rete::Rete_Node_Ptr, std::vector<std::array<std::string, 3>>>, std::string, tuple<int64_t, string, Carli::Feature *>>(*$3, *$2, tuple<int64_t, string, Carli::Feature *>());
                                    delete $2;
                                    delete $3; }
  | '{' STRING flag final_conditions '}' { $$ = new tuple<std::pair<Rete::Rete_Node_Ptr, std::vector<std::array<std::string, 3>>>, std::string, tuple<int64_t, string, Carli::Feature *>>(*$4, *$2, *$3);
                                           delete $2;
                                           delete $3;
                                           delete $4; }
  ;
flag:
  /* :feature q_value->depth [feature->depth feature->lower_bound feature->upper_bound] */
  FLAG_FEATURE INT NODE_TYPE INT FLOAT FLOAT { $$ = new tuple<int64_t, string, Carli::Feature *>($2, *$3, new Carli::Feature_Ranged<Carli::Feature>(Rete::WME_Token_Index() /*FIXUP later*/, $5, $6, $4, false /*FIXUP later*/, false));
                                               delete $3; }
  | FLAG_FEATURE INT NODE_TYPE INT INT INT { $$ = new tuple<int64_t, string, Carli::Feature *>($2, *$3, new Carli::Feature_Ranged<Carli::Feature>(Rete::WME_Token_Index() /*FIXUP later*/, $5, $6, $4, false /*FIXUP later*/, true));
                                             delete $3; }
  | FLAG_FEATURE INT NODE_TYPE { $$ = new tuple<int64_t, string, Carli::Feature *>($2, *$3, $2 > 1 ? new Carli::Feature_Enumerated<Carli::Feature>(Rete::WME_Token_Index() /*FIXUP later*/, 0 /*FIXUP later*/) : nullptr);
                                 delete $3; }
  ;
final_conditions:
  conditions { $$ = $1; }
  | '+' conditions { $$ = Rete_Node_Ptr_and_Variables(Rete::Rete_Node_Ptr(agent.make_existential($2->first)), Variables()); delete $2; }
  | '-' conditions { $$ = Rete_Node_Ptr_and_Variables(Rete::Rete_Node_Ptr(agent.make_negation($2->first)), Variables()); delete $2; }
  | final_conditions '+' condition_type { $$ = Rete_Node_Ptr_and_Variables(Rete::Rete_Node_Ptr(agent.make_existential_join(join_bindings($1->second, $3->second), $1->first, $3->first)), $1->second);
                                          delete $1;
                                          delete $3; }
  | final_conditions '-' condition_type { $$ = Rete_Node_Ptr_and_Variables(Rete::Rete_Node_Ptr(agent.make_negation_join(join_bindings($1->second, $3->second), $1->first, $3->first)), $1->second);
                                          delete $1;
                                          delete $3; }
  ;
conditions:
  conditions condition_type { vector<array<string, 3>> variables($1->second);
                              variables.insert(variables.end(), $2->second.begin(), $2->second.end());
                              $$ = Rete_Node_Ptr_and_Variables(Rete::Rete_Node_Ptr(agent.make_join(join_bindings($1->second, $2->second), $1->first, $2->first)), variables);
                              delete $1;
                              delete $2; }
  | conditions '(' VARIABLE PREDICATE symbol_constant ')' { const auto lhs_index = find_index($1->second, *$3);
                                                            if(lhs_index.second > 2) {
                                                              reteerror(&yylloc, yyscanner, agent, filename, source_path, gufv, "Unbound variable tested by predicate.");
                                                              YYABORT;
                                                            }
                                                            $$ = Rete_Node_Ptr_and_Variables(Rete::Rete_Node_Ptr(agent.make_predicate_vc($4, lhs_index, *$5, $1->first)), $1->second);
                                                            delete $1;
                                                            delete $3;
                                                            delete $5; }
  | conditions '(' VARIABLE PREDICATE VARIABLE ')' { const auto lhs_index = find_index($1->second, *$3);
                                                     const auto rhs_index = find_index($1->second, *$5);
                                                     if(lhs_index.second > 2 || rhs_index.second > 2) {
                                                       reteerror(&yylloc, yyscanner, agent, filename, source_path, gufv, "Unbound variable tested by predicate.");
                                                       YYABORT;
                                                     }
                                                     $$ = Rete_Node_Ptr_and_Variables(Rete::Rete_Node_Ptr(agent.make_predicate_vv($4, lhs_index, rhs_index, $1->first)), $1->second);
                                                     delete $1;
                                                     delete $3;
                                                     delete $5; }
  | condition_type { $$ = $1; }
  ;
condition_group:
  '{' final_conditions '}' { $$ = $2; }
  ;
condition_type:
  condition { $$ = $1; }
  | condition_group { $$ = $1; }
  ;
condition:
  '(' VARIABLE '^' symbol_constant symbol_constant ')' { $$ = Rete_Node_Ptr_and_Variables(Rete::Rete_Node_Ptr(agent.make_filter(Rete::WME(make_shared<Rete::Symbol_Variable>(Rete::Symbol_Variable::First), *$4, *$5))), Variables(Variable(*$2, "", ""))); delete $2; delete $4; delete $5; }
  | '(' VARIABLE '^' symbol_constant VARIABLE ')'  { $$ = Rete_Node_Ptr_and_Variables(Rete::Rete_Node_Ptr(agent.make_filter(Rete::WME(make_shared<Rete::Symbol_Variable>(Rete::Symbol_Variable::First), *$4, make_shared<Rete::Symbol_Variable>(*$2 == *$5 ? Rete::Symbol_Variable::First : Rete::Symbol_Variable::Third)))), Variables(Variable(*$2, "", *$5))); delete $2; delete $4; delete $5; }
  | '(' VARIABLE '^' VARIABLE symbol_constant ')' { $$ = Rete_Node_Ptr_and_Variables(Rete::Rete_Node_Ptr(agent.make_filter(Rete::WME(make_shared<Rete::Symbol_Variable>(Rete::Symbol_Variable::First), make_shared<Rete::Symbol_Variable>(*$2 == *$4 ? Rete::Symbol_Variable::First : Rete::Symbol_Variable::Second), *$5))), Variables(Variable(*$2, *$4, ""))); delete $2; delete $4; delete $5; }
  | '(' VARIABLE '^' VARIABLE VARIABLE ')'  { $$ = Rete_Node_Ptr_and_Variables(Rete::Rete_Node_Ptr(agent.make_filter(Rete::WME(make_shared<Rete::Symbol_Variable>(Rete::Symbol_Variable::First), make_shared<Rete::Symbol_Variable>(*$2 == *$4 ? Rete::Symbol_Variable::First : Rete::Symbol_Variable::Second), make_shared<Rete::Symbol_Variable>(*$2 == *$5 ? Rete::Symbol_Variable::First : *$4 == *$5 ? Rete::Symbol_Variable::Second : Rete::Symbol_Variable::Third)))), Variables(Variable(*$2, *$4, *$5))); delete $2; delete $4; delete $5; }
  ;
symbol:
  symbol_constant { $$ = $1; }
  | identifier { $$ = $1; }
  ;
identifier:
  '@' STRING { $$ = new Rete::Symbol_Ptr_C(make_shared<Rete::Symbol_Identifier>(*$2)); delete $2; }
  ;
symbol_constant:
  FLOAT { $$ = new Rete::Symbol_Ptr_C(make_shared<Rete::Symbol_Constant_Float>($1)); }
  | INT { $$ = new Rete::Symbol_Ptr_C(make_shared<Rete::Symbol_Constant_Int>($1)); }
  | string_or_literal { $$ = new Rete::Symbol_Ptr_C(make_shared<Rete::Symbol_Constant_String>(*$1)); delete $1; }
  ;
string_or_literal:
  STRING { $$ = $1; }
  | literal { $$ = $1; }
  ;
literal:
  '|' literal_parts '|' { $$ = $2; }
  ;
literal_parts:
  literal_parts STRING_PART_C { $$ = $1; *$$ += $2; }
  | literal_parts STRING_PART_S { $$ = $1; *$$ += *$2; delete $2; }
  | STRING_PART_C { $$ = new string; *$$ += $1; }
  | STRING_PART_S { $$ = $1; }
  ;

%%

bool rete_get_exit() {
  return g_rete_exit;
}

int rete_parse_file(Carli::Agent &agent, const string &filename, const std::string &source_path) {
  if(filename.empty())
    return -1;

  string source_path_full = source_path;
  string filename_part = filename;
  string filename_full;
  const size_t filename_slash_pos = filename.find_last_of("/\\");
  if(filename_slash_pos != string::npos) {
    if(filename[0] == '/' || filename[0] == '\\')
      source_path_full.clear();
    source_path_full += filename.substr(0, filename_slash_pos + 1);
    filename_part = filename.substr(filename_slash_pos + 1);
  }
  filename_full = source_path_full + filename_part;

  //cerr << "Sourcing '" << filename_part << "' from '" << source_path_full << '\'' << endl;

  FILE * file = fopen(filename_full.c_str(), "r");
  if(!file)
    return -1;

  yyscan_t yyscanner;
  if(retelex_init(&yyscanner)) {
    fclose(file);
    return -1;
  }

  int rv = 0;
  Grandparent_to_UFV gufv;

  reterestart(file, yyscanner);
  reteset_lineno(1, yyscanner);

  // retelex();
  do {
    rv = reteparse(yyscanner, agent, filename_full, source_path_full, gufv);
    if(rv)
      break;
  } while (!feof(reteget_in(yyscanner)));

  retelex_destroy(yyscanner);
  fclose(file);

  for(auto &entry : gufv) {
    assert(entry.second.first);
    assert(!entry.second.second.empty());
    entry.second.first->fringe_values.swap(entry.second.second);
  }

  return rv;
}

int rete_parse_string(Carli::Agent &agent, const string &str, int &line_number) {
  int rv = 0;
  Grandparent_to_UFV gufv;

  yyscan_t yyscanner;
  if(retelex_init(&yyscanner))
    return -1;

  YY_BUFFER_STATE buf = rete_scan_string(str.c_str(), yyscanner);
  reteset_lineno(line_number, yyscanner);

  // retelex();
  rv = reteparse(yyscanner, agent, "", "", gufv);

  line_number = reteget_lineno(yyscanner) + 1;

  rete_delete_buffer(buf, yyscanner);
  retelex_destroy(yyscanner);

  for(auto &entry : gufv) {
    assert(entry.second.first);
    assert(!entry.second.second.empty());
    entry.second.first->fringe_values.swap(entry.second.second);
  }

  return rv;
}

void rete_set_exit() {
  g_rete_exit = true;
}
